---
title: 数据库知识整理
date: 2019-03-30 12:48:14
tags: [面试,数据库]
categories: [面试,数据库]
description: 数据库知识整理
---

# 数据库相关总结

---

参考：https://www.weiweiblog.cn/databases/

---

## 1. 范式
### 1. 第一范式
每个属性都不可再分。
### 2. 第二范式
**消除了非主属性对于码的部分函数依赖。**
所有非主属性都必须和主键有完全依赖关系，不能存在有某个非主属性只和主键的一部分有关。


```
部分函数依赖：若XY是关系R中的属性，X->Y，X'是X的子集，若存在X'->Y，则Y部分函数依赖X。

安全函数依赖：若XY是关系R中的属性，X->Y，X'是X的子集，若每个X'！->Y，则Y完全函数依赖X。

传递函数依赖：在关系R(U)中，XYZ是R的三个属性集合，若X确定Y，Y确定Z，X不包含Y，Y不确定Z，(XUY)∩Z为空，则称Z传递函数依赖于X。
```

### 3. 第三范式
**消除了非主属性对于码的传递函数依赖。**
不仅要满足第二范式，而且所有属性都要互相独立，没有传递关系。

---

## 2. 数据库索引
索引通常是由B树或者B+树实现。
### 2.1. B树和B+树的区别
- B树的键和值也存在内部节点和叶子结点中，B+树内部结点只存键，叶子结点存键和值。
- B+树的叶子结点有一条链相连。

##### B树的好处
B树在内部存键值，频繁访问的节点在根节点附近可以提高查询效率，如果特定数据是重复读取，B树更好。
##### B+树的好处
一次读取大量数据时，因为B+树内部节点只存键，因此可以读取更多键，又因为叶子节点有链，读取大量数据时不需要每次都遍历内部节点。

### 2.2. 数据库使用B+还是B
**B树只适合随机检索，B+树同时适合随机检索和顺序检索。**

**B+树空间利用率更高，I/O次数少，磁盘读写少。**
索引也很大，需要以文件的形式存在磁盘中。索引查找就会产生I/O操作。B+树可以一次读取更多的关键字，因此I/O次数少。

**B+树查询效率更稳定。**
B树关键字在内部节点中也有，找到关键字就能确定记录。性能代价相当于二分查找。
B+树每次都是跟到叶节点，效率更稳定。

**B+树顺序遍历效率也不低。**
B+树叶子结点有链。

### 2.3. 索引类型

- 主键索引：数据列不允许重复，不允许为null，一个表只能有一个主键索引。
- 唯一索引：数据列不允许重复，允许为null，一个表允许多个列创建唯一索引。
- 普通索引：没有唯一性限制，可以为空。
- 全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。
- 联合索引：可以多个列共同创建联合索引。一个查询可以使用其中一个列，但必须遵守最左前缀原则。

### 2.4. 聚集索与非聚集索
- 聚集索引：各行的物理顺序和逻辑顺序相同，一个表只能有一个。
- 非聚集索引：数据与索引在不同位置，索引中存在指向数据的指针，可以有多个。非聚集索引，分成普通索引，唯一索引，全文索引。

InnoDB的数据文件本身就是索引文件。InnoDB数据文件按聚集索引，所以InnoDB必须有主键。InnoDB聚集索引规则：
1. 如果有主键，主键就是聚集索引。
2. 如果没有主键，第一个唯一非空索引就是聚集索引。
3. 如果1、2都没有，会生成一个隐藏的主键作为聚集索引，它是6个字节的列，随着数据插入自增。

### 2.5. MyISAM和InnoDB索引实现

索引 | MyISAM | InnoDB
---|---|---
主键索引 | 在主键索引中，索引页中存放的是主键和指向数据页的偏移量；数据页中存放的是主键和该主键所属行记录的地址空间。 | 索引页仍然存放主键和和指向数据页的偏移量，但数据页存放的是完整的记录。也就是在InnoDB中，数据和主键索引是存放在一起的。
辅助索引 | 在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。综上所述，在MyISAM中，索引文件和数据文件分开存放，不管是主键索引还是辅助索引，都属于非聚集索引。  | 索引节点存放的内容一样，仍然是键值信息和指向数据页的偏移量；但数据页中存放的是键值信息和该键值对应的主键。然后通过主键查询主键索引就能找到该条记录。

### 2.6. 索引的优点
- 创建唯一性索引，可以确保每行数据的唯一性。
- 提高数据检索效率。
- 加快表与表之间的连接。
- 使用分组和排序字句检索时，可以加快检索时间。
- 通过使用索引，在查询过程中，使用查询优化器，提高系统性能。

### 2.7. 索引的缺点
- 时间方面：创建和维护需要时间。对数据增删改也需要对索引维护。
- 空间方面：索引需要占据物理空间。


### 2.8. 索引的优化
- 非空字段：索引的列最好为非空。空值很难优化，用其他方式（0，特殊值等）代替空值。
- 取离散大的列：将更离散的数据放在联合索引前面。
- 索引字段越小越好：数据以页为单位存储，一页数据越多，一次IO操作得到的数据越多。
- 对 where,on,group by,order by 中出现的列使用索引。
- 对于like查询，%不放在前面。
- 最左前缀匹配原则。

### 2.9. 最左前缀匹配原则
mysql会向右匹配到范围查询（<,>,between等），=、in放在左边。 = in 可以乱序。

---
## 3. 事务

事务是一个不可分割的数据库操作序列，是数据库并发操作的基本单位，其结果是从一种一致性状态到另一种一致性状态。

### 3.1. 四大特性（ACID）

#### 原子性（Atomicity）
事务是数据库逻辑工作单位，其操作要么全做，要么全不做。

#### 一致性（Consistency）
其结果必须是从一种一致性状态到另一种一致性状态。

#### 隔离性（Isolation）
一个事务的执行不能被其他事务干扰。

#### 持久性（Duration）
持久性表示一旦事务被提交了，数据库的数据改变就是永久性的，即使遇到故障也不会丢失提交的操作。

### 3.2. 不考虑隔离性会出现的问题

- **脏读**： 一个事务读到了另一个未提交事务的数据。
- **不可重复读**：一个事务两次查询的间隔中，另一个事务修改并提交了数据，导致两次查询结果不同。
- **幻读**：一个事务两次查询中数据笔数不一致。

不可重复读和幻读都是查询中被另一个事务修改并提交了，不同的是不可重复读查询的是同一条数据，幻读是一批数据（比如数据的条数）。

### 3.3 隔离级别

- **Read Uncommitted(读未提交)**：所有事务都可以看到其他事务未提交的结果。一般很少用。
- **Read commited(读已提交)**：一个事务只能看见已提交的结果。除mysql外大多数数据库默认。
- **Repeatable Read(可重复读)**：确保了同一个事务的多个实例并发读数据时能看到相同的结果。mysql默认。
- **Serializable(顺序读)**：最高的隔离级别，解决了幻读，但会出现大量超时和锁竞争。

#### 事务隔离级别对比


事务隔离级别 | 脏读 | 不可重复读 | 幻读
---|:-:| :-:|:-:
Read Uncommitted | 允许 | 允许 | 允许
Read commited | 不允许 | 允许 | 允许
Repeatable Read | 不允许 | 不允许 | 允许
Serializable | 不允许 | 不允许 | 不允许

#### 隔离级别与锁
Read Uncommitted：读操作不加S锁。
Read commited：读操作加S锁，在语句执行完释放锁。
Repeatable Read：读操作加S锁，事务提交后释放锁。
Serializable：在Repeatable read的基础上，加范围锁。

### 3.4. 操作
start transaction;开始事务

commit; 提交

rollback; 回滚

---

## 4. 其他知识

### 4.1. delete truncate drop区别

区别 | delete | truncate | drop
---|--- | --- | ---
类型回滚 | 可回滚 | 不可回滚 | 不可回滚
删除内容 | 表结构还在，删除表全部或部分内容 | 表结构还在，删除全部内容 | 删除表，所有数据、索引、权限一并删除
删除速度 | 逐行删除，速度慢 | 速度快 | 速度快

### 4.2. 存储过程
预编译的sql语句，一次创建，多次使用。
#### 优点
1. 预编译，效率高。
2. 存放在数据库，减少网络传输。
3. 安全性高，需要一定权限。
4. 一次创建可多次使用，提高开发效率。

### 4.3. 视图
从一个表或多个表导出的表，是虚表，不存具体数据。

### 4.4. 主从复制
将主数据库的DDL、DML操作记录到二进制文件（BINLOG），传输到从数据库，从数据库重新执行，使得从数据库数据和主数据库保持一致。

#### 主从复制作用
- 主数据库故障可以切换到从数据库；
- 可以读写分离；
- 从数据库可以日志备份。

#### 复制过程
1. 主数据库更新数据完成前，将操作记录顺序记录到BINLOG；
2. 从数据库开启一个I/O线程，该线程在主数据库打开一个普通连接，将读到的事件写入到中继日志，如果读取的进度跟上了master，就进入睡眠等待；
3. 从数据库的SQL线程将读取中继日志，并顺序执行操作。

### 4.5. 大表数据查询的优化
1. 优化Schema，sql语句、索引。
2. 加缓存，memcached，redis
3. 主从复制，读写分离
4. 垂直拆分，分布式系统
5. 水平切分，要选择合适的sharding key，为了好的查询效率，表结构也要改变，应用也需要改变，sql中尽量带sharding key，将数据定位到限定的表去查，而不是全部的表。

---

## 5. MVCC
参考：[MVCC多版本并发控制浅析](https://blog.csdn.net/h330531987/article/details/74364018)


MVCC，多版本并发控制，是mysql数据库InnoDB引擎隔离级别的实现。用于Read Committed和Repeatable Read两种隔离级别。

InnoDB会为每一行添加两个字段，分别表示**创建的版本**和**删除的版本**，填入的是事务的版本号，这个版本号随着事务的创建不断递增，具体实现：
- **select**：满足一下两个条件会返回该行数据：1、 该行的创建版本号小于等于当前版本号，用来确保select操作之前的操作已经执行落地；2、该行的删除版本号大于当前版本号或为空，大于说明当前版本已经有一个并发事务将该行删除了。
- **insert**：将新插入的行的创建版本号设置为当前的系统版本号。
- **delete**：将要删除的行的删除版本号设置为当前的系统版本号。
- **update**：不执行原地操作，还是转化为insert+delete，对旧行执行delete，对新行执行insert。

写操作（update、insert、delete）执行时，将当前的系统版本号递增。

由于旧数据不是真正的删除，所以要对这些数据进行清理，innoDB会开一个后台线程执行，具体规则是将删除版本号小于当前系统版本号的行输出，这个过程叫purge。

MVCC能达到Repeatable Read，但是想达到Serializable还要加锁。

---
## 6. 封锁
[数据库锁](https://blog.csdn.net/fantalee/article/details/81661665 )
### 6.1. 封锁粒度
MySQL 中提供了两种封锁粒度：行级锁以及表级锁。

在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。

### 6.2. 封锁类型
#### 读写锁
- 排它锁（Exclusive），简写为 X 锁，又称写锁。 
- 共享锁（Shared），简写为 S 锁，又称读锁。 

1. 一个事务对数据对象(数据库、表、页或者行) A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 
2. 一个事务对数据对象(数据库、表、页或者行) A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 


· | X | S
:-:|:-:|:-:
X | × | × 
S | × | √

#### 意向锁
InnoDB把意向锁设计得比较简练，没有上面定义那么复杂。其意向锁就是表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。 
由此，意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：
1. 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁； 
2. 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

事务 T 想要对表 A 加 X 锁时，只需要先检测是否有其它事务在表 A门口加没加 S/X/IX/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 为整张表加 X 锁失败。进入等待。

表级意向锁与表级的X，S的兼容关系如下（IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突）：

· | X |IX | S | IS
:-:|:-:|:-:|:-:|:-:
X | × | × | × | ×
IX | × | √ | × | √
S | × | × | √ | √
IS | × | √ | √ | √

### 6.3. 三级封锁协议
<font color='red'>保证数据一致性</font>

#### 一级封锁协议
事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

没法解决**脏读、不可重复读**。

#### 二级封锁协议
在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。

**不可重复读**问题还是没有解决。

#### 三级封锁协议
在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。

### 6.4. 两段锁协议
<font color='red'>保证并行调度可串行化</font>

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。

规定在对任何数据进行读写操作之前，事务首先要获得对该数据的封锁；而且在释放一个封锁之后，事务不再获得任何其他封锁。

就是说加锁和解锁分为两个阶段进行。

### 6.5. MySQL 隐式与显示锁定
MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

InnoDB 也可以使用特定的语句进行显示锁定：

```
SELECT … LOCK In SHARE MODE; 
SELECT … FOR UPDATE;
```

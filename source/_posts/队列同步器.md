---
title: 队列同步器（AQS）
date: 2019-05-11 15:47:59
tags: [面试,Java,锁]
categories: [面试,Java,锁]
description: 队列选择器（AbstractQueuedSynchronizer）是用来构建锁或者其他同步组件的基础框架。
---

# 队列同步器（AQS）

队列选择器（AbstractQueuedSynchronizer）是用来构建锁或者其他同步组件的基础框架。

同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。

同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。**锁是面向使用者的，同步器面向的是锁的实现者。**

## 接口

同步器的设计是基于模板方法。使用者继承同步器并重写制定的方法，随后将同步器组合在自定义同步组件的实现中，并调用模板方法，模板方法调用的是使用者重写的方法。

同步器提供3个方法访问和修改同步状态：

- getState()：获取当前同步状态。
- setState(int newState)：设置当前同步状态。
- compareAndSetState(int expect, int update)：使用CAS设置。

同步器可重写的方法：

- protected boolean tryAcquire(int arg)：独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再使用CAS设置同步状态。
- protected boolean tryRelease(int arg)：独占式释放同步状态，等待同步状态的线程将有机会获取同步状态。
- protected int tryAcquireShared(int arg)：共享式获取同步状态，返回大于等与0的值则表示获取成功，否则获取失败
- protected boolean tryReleaseShared(int arg)：共享式释放同步状态。
- protected boolean isHeldExclusively()：当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占。

模板方法：

- public final void acquire(int arg)：独占式获取同步状态，如果当前线程获取同步状态成功，则会返回，否则当前线程会进入同步队列等待，该方法需要调用重写的tryAcquire(int arg)方法
- public final void acquireInterruptibly(int arg) throws InterruptedException：独占式获取同步状态，如果当前线程获取同步状态成功，则会返回，否则当前线程会进入同步队列等待，但同时该方法也会响应中断，如果线程在同步队列中被中断，则该方法会抛出InterruptedException并返回。
- public final boolean tryAcquireNanos(int arg, long nanosTimeout)
              throws InterruptedException：在acquireInterruptibly(int arg)增加了超时限制，超时未获得同步状态返回false，否则返回true
- public final void acquireShared(int arg)：共享式获取同步状态，如果未获取到则进入同步队列等待，与独占式不同的是，共享式可以同时有多个线程获取到同步状态。
- public final void acquireSharedInterruptibly(int arg)：共享式获取同步状态，如果当前线程获取同步状态成功，则会返回，否则当前线程会进入同步队列等待，但同时该方法也会响应中断，如果线程在同步队列中被中断，则该方法会抛出InterruptedException并返回。
- public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
              throws InterruptedException：在acquireSharedInterruptibly(int arg)基础上增加了超时限制，超时未获得同步状态返回false，否则返回true
- public final boolean release(int arg)：独占式释放同步状态，该方法会在释放同步状态之后，唤醒同步队列中第一个节点中的线程。
- public final boolean releaseShared(int arg)：共享式释放同步状态。
- public final Collection<Thread> getQueuedThreads()：获取在同步队列上等待的线程集合。

## 实现

### 共享式获取与独占式获取

- 共享式访问资源时，其他共享式的访问均被允许，独占式访问被阻塞。
- 独占式访问资源时，其他访问均被阻塞。

### 同步队列

同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点并加入队列，同时阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。

节点是构成同步队列的基础，同步器拥有首节点和尾节点，没有成功获取同步状态的线程会将成为节点加入该队列的尾部。

- 设置尾节点需要CAS方法：compareAndSetTail(Node expect, Node update)。
- 获取首节点是通过同步成功的线程，所以不需要CAS。

### 独占式同步状态

通过acquire(int arg)可以获取同步状态。主要逻辑：

首先调用自定义同步器实现的tryAcquire(int arg)方法（保证线程安全的获取同步），通过addWaiter(Node node)方法将该节点加入到队列尾部，最后acquireQueued(Node node, int arg)，使得该节点以死循环的方式获取同步状态。

![aqc_ex.png](\image\interview_prep\java\aqc_ex.png)

通过release(int arg)方法可以释放同步状态，该方法释放了同步状态后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）。

### 共享式同步状态

通过调用acquireShared(int arg)可以共享式获取同步状态。具体：

- 调用tryAcquireShared(int arg)尝试获取同步状态，当返回值大于等于0，表示能获取到同步。

- doAcquireShared(int arg)自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步，如果返回值大于等于0，表示获取成功并退出自旋。

调用releaseShared(int arg)释放同步状态。和独占式的区别是tryReleaseShared(int arg)必须保证同步状态线程安全释放，一般是通过循环和CAS保证。

### 独占式超时获取同步

通过调用doAcquireNanos(int arg, long nanosTimeout)可以超时获取同步。在支持响应中断的基础上，增加了超时获取的特性。

过程和独占式类似，但在同步获取失败时判断是否超时。

- 如果没有超时，重新 计算超时间隔，然后使当前线程等待nanosTimeout。
- 如果nanosTimeout小于等于spinForTimeoutThrehold时，将不会将使该线程进行超时等待，而是进入快速自旋。

![aqs_nano.png](\image\interview_prep\java\aqs_nano.png)

参考：

[深入学习Lock锁（1）——队列同步器](<https://yq.aliyun.com/articles/639608>)
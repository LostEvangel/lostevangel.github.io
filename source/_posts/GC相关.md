---
title: GC相关
date: 2019-4-16 14:37:09
tags: [面试,JVM]
categories: [面试,JVM]
description: Java面试中，关于GC的知识。
---

# GC相关

## 1. 垃圾收集器

程序计数器、虚拟机栈、本地方法栈随线程生死，不需要太考虑回收。而Java堆和方法区只有在运行期间才知道创建哪些对象，这部分内存分配和回收都是动态的，GC要关注的是这部分。

引用技术算法：给对象添加一个引用计数器，有引用，+1，引用失效，-1，任何时刻计数器为0的对象不能被使用。但是解决不了对象相互循环引用的问题，故基本不用。

### 可达性分析算法

基本思想：通过一系列的GC Roots对象作为起始点，向下搜索，当一个对象到GC Roots没有任何引用链相连，则这个对象是可回收的。

可以作为GC Roots的对象：

- 虚拟机栈（本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈JNI（一般指Native方法）引用的对象

### 4种引用

- 强引用：“Object obj = new Object()”这类的引用，只要引用存在，GC就不会回收。
- 软引用：有用但非必需的对象。在系统将要发生内存溢出之前，会把这些对象列进回收范围中进行二次回收。如果仍没有足够内存，才会抛出内存溢出异常。SoftReference类实现。
- 弱引用：强度比软引用更弱，只能生存到下一次垃圾回收前，当GC工作，无论当前内存是否足够，都会被回收。WeakReference类实现。
- 虚引用：唯一目的就是能在GC时收到一个系统通知。PhantomReference类实现。

### finalize方法

- finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。
- finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)
- 大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。

### 方法区的回收

方法区（永久代）回收主要两方面：废弃常量和无用的类。

判断方法，满足一下3个条件：

- 该类所有实例都被回收
- 加载该类的类加载器被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射获得该类的方法。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景需要回收方法区，保证永久代不溢出。

## 2. 垃圾收集算法

### 标记-清除算法

先标记所有需要回收的对象，标记完成后统一回收所有被标记的对象。

缺点：效率不高；会产生大量不连续的内存碎片。

### 复制算法

把内存划分成大小相同的两块，当一块用完了，将存活的对象复制到另一块内存，然后将使用过的内存一次清理掉。

大部分虚拟机用**复制算法回收新生代**。将内存分为一块大的Eden，和两块小的Survivor，每次使用Eden和一个Survivor。回收时将Eden和Survivor中存活的对象复制到另一个Survivor上，然后清理。默认Eden和Survivor比例是8:1。当Survivor空间不够时，需要依赖老年代进行分配担保。

### 标记-整理算法

复制收集算法在对象存活率高时效率不高，**老年代使用标记-整理算法**，标记同标记-清除算法，整理是让所有存活的对象向一段移动，然后清理掉边界以外的内存。

### 分代收集算法

GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。

“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

## 3. 垃圾收集器

### Serial收集器

![serial.png](\image\interview_prep\JVM\serial.png)

串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）

参数控制：-XX:+UseSerialGC  串行收集器。

### ParNew收集器

![parnew.png](\image\interview_prep\JVM\parnew.png)

ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩

参数控制：-XX:+UseParNewGC  ParNew收集器

-XX:ParallelGCThreads 限制线程数量。

### Parallel收集器

Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩

参数控制：-XX:+UseParallelGC  使用Parallel收集器+ 老年代串行。

### Serial Old收集器

Serial Old是Serial的老年代版本，**单线程，标记-整理算法**。

两个用途：与Parallel Scavenge搭配使用；作为CMS收集器的后备预案，发生Concurrent Mode Failure时使用。

### Parallel old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，使用**多线程和“标记－整理”算法**。

参数控制： -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行。

### CMS收集器

![CMS.png](\image\interview_prep\JVM\CMS.png)

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： 

- 初始标记（CMS initial mark）
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 

由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）

优点：并发收集、低停顿 
缺点：产生大量空间碎片、并发阶段会降低吞吐量

参数控制：
-XX:+UseConcMarkSweepGC  使用CMS收集器
-XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长
-XX:+CMSFullGCsBeforeCompaction  设置进行几次Full GC后，进行一次碎片整理
-XX:ParallelCMSThreads  设定CMS的线程数量（一般情况约等于可用CPU数量）

### G1收集器

[详解 JVM Garbage First(G1) 垃圾收集器](https://blog.csdn.net/coderlius/article/details/79272773)

G1收集器（Garbage-First）：是当今收集器技术发展的最前沿的成果之一，G1是一款面向服务器端应用的垃圾收集器。 使用G1收集器时，java堆的内存布局就与其他收集器有很大差别，它将整个java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代与老年代的概念，但新生代与老年代不再试物理隔离的了，他们都是一部分Region（不需要连续）的集合。G1具备如下特点：

- **并行与并发**：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
- **分代收集**：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能够独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。
- **空间整合**：G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。
- **可预测停顿**：这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

收集步骤：

1. **初始标记 Initial Mark**，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)
2. **根分区扫描 Root Region Scanning**，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。
3. **并发标记 Concurrent Marking**，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。
4. **存活数据计算 Live Data Accounting**，存活数据计算(Live Data Accounting)是标记操作的附加产物，只要一个对象被标记，同时会被计算字节数，并计入分区空间。只有NTAMS以下的对象会被标记和计算，在标记周期的最后，Next位图将被清空，等待下次标记周期。
5. **重新标记 Remark**, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。
6. **清除 Copy/Clean up**，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。
7. 复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。
---
title: 常用设计模式
date: 2019-3-28 11:10:51
tags: [面试,设计模式]
categories: [面试,设计模式]
description: 面试中可能会问到的设计模式，自己写的范例
---




# 常用设计模式（java）
[23种常用设计模式的UML类图](https://www.cnblogs.com/zytrue/p/8484806.html)

## 1. 创建型

### 1.1 三种工厂模式

#### 1. 简单工厂模式
参考：
[java 三种工厂模式](https://www.cnblogs.com/zailushang1996/p/8601808.html)

简单工厂模式又 叫静态工厂方法模式（Static FactoryMethod Pattern），是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

##### 代码示例：
一个抽象的武器接口：

```java
public interface ISword{
    void swordSkill();
}
```

一个具体产品类，武器阐释者：

```java
public class ChanShiZhe implements ISword{
    @Override
    public void swordSkill(){
        System.out.println("阐释者——星爆弃疗斩");
    }
}
```

另一个具体产品类，武器闪烁之光：
```java
public class ShanShuoZhiGuang implements ISword{
    @Override
    public void swordSkill(){
        System.out.println("闪烁之光——圣母圣咏");
    }
}
```

简单工厂类：
```java
public class SimplySwordFactory{
    public static final int TYPE_CSZ = 1;
    public static final int TYPE_SSZG = 2;
    
    public static ISword createSword(int type){
        switch(type){
            case TYPE_CSZ: 
                return new ChanShiZhe();
            case TYPE_SSZG:
                return new ShanShuoZhiGuang();
            default:
                return new ChanShiZhe();
        }
    }
}
```

测试：
```java
public class SimpleFactoryTest {
    public static void main(String[] args){
        ISword sword = SimplySwordFactory.createSword(SimplySwordFactory.TYPE_CSZ);
        sword.swordSkill();
    }
}
```
##### 总结
特点：
- 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。
- create()方法通常是静态的，所以也称之为静态工厂。
缺点：
- 扩展性差（我想增加一种武器，除了新增一个武器产品类，还需要修改工厂类方法）
- 不同的产品需要不同额外参数的时候 不支持。

#### 2. 工厂方法
![FactoryMethod](/image/interview_prep/FactoryMethod.png)

提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例。

步骤：
1. 创建抽象工厂类，定义具体工厂的公共接口；
2. 创建抽象产品类 ，定义具体产品的公共接口；
3. 创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
4. 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；
5. 外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例

##### 代码示例：
工厂接口：
```java
public interface Factory {
    ISword createSword();
}
```
其实现类（获取具体产品）:
```java
public class ChanShiZheFactory implements Factory{
    @Override
    public ISword createSword(){
        return new ChanShiZhe();
    }
}
```

```java
public class ShanShuoZhiGuangFactory implements Factory{
    @Override
    public ISword createSword(){
        return new ShanShuoZhiGuang();
    }
}
```
测试：
```java
public class FactoryTest {
    public static void main(String[] args){
        ISword csz = new ChanShiZheFactory().createSword();
        csz.swordSkill();
        ISword sszg = new ShanShuoZhiGuangFactory().createSword();
        sszg.swordSkill();
    }
}
```

##### 总结
优点：
- 更符合开-闭原则：新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可
- 符合单一职责原则：每个具体工厂类只负责创建对应的产品
- 不使用静态工厂方法，可以形成基于继承的等级结构

缺点：
- 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
- 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类
- 一个具体工厂只能创建一种具体产品


#### 3. 抽象工厂模式
参考：
[Java设计模式之抽象工厂模式](https://www.cnblogs.com/yeahwell/p/4727202.html)

![AbstractFactory](/image/interview_prep/AbstractFactory.png)

当每个抽象产品都有多于一个的具体子类的时候（空调有型号A和B两种，发动机也有型号A和B两种），工厂角色怎么知道实例化哪一个子类呢？比如每个抽象产品角色都有两个具体产品（产品空调有两个具体产品空调A和空调B）。抽象工厂模式提供两个具体工厂角色（宝马320系列工厂和宝马230系列工厂），分别对应于这两个具体产品角色，每一个具体工厂角色只负责某一个产品角色的实例化。每一个具体工厂类只负责创建抽象产品的某一个具体子类的实例。

##### 代码示例：
产品类：

```java
// 武器及型号
public interface Sword {
    void equip();
}

public class SwordA implements Sword{
    public void equip(){
        System.out.println("装备-->双刀");
    }
}
public class SwordB implements Sword{
    public void equip(){
        System.out.println("装备-->细剑");
    }
}

//技能及型号
public interface Skill {
    void release();
} 
public class SkillA implements Skill{
    public void release(){
        System.out.println("发动-->双刀流");
    }
}
public class SkillB implements Skill{
    public void release(){
        System.out.println("发动-->圣母圣咏");
    }
}
```
创建工厂类

```java
//创建工厂的接口  
public interface AbstractFactory {  
    //装备武器
    public Sword createSword();
    //装备技能 
    public Skill createSkill(); 
}  


//为桐人装备  
public class Factorykirito implements AbstractFactory{  
      
    @Override  
    public Sword createSword() {    
        return new SwordA();  
    }  
    @Override  
    public Skill createSkill() {  
        return new SkillA();  
    }  
}  
//为亚丝娜装备 
public class FactoryAsuna implements AbstractFactory {  
  
     @Override  
    public Sword createSword() {    
        return new SwordB();  
    }  
    @Override  
    public Skill createSkill() {  
        return new SkillB();  
    }  
} 
```

测试类:
```java
public class FactoryTest  {  
    public static void main(String[] args){  
        //生产桐人
        Factorykirito factorykirito = new Factorykirito();
        System.out.println("这是桐人");
        factorykirito.createSword().equip();
        factorykirito.createSkill().release();

        //生产亚丝娜
        FactoryAsuna factoryAsuna = new FactoryAsuna();
        System.out.println("这是亚丝娜");
        factoryAsuna.createSword().equip();
        factoryAsuna.createSkill().release(); 
    }
}
```
控制台输出：
```
这是桐人
装备-->双刀
发动-->双刀流
这是亚丝娜
装备-->细剑
发动-->圣母圣咏
```


### 1.2. 七种单例模式
参考： 
[Java 单例模式](https://www.cnblogs.com/zhaoyanjun/p/5652930.html)

为什么使用单例：
- 在内存中只有一个对象，节省内存空间。避免频繁的创建销毁对象，可以提高性能。避免对共享资源的多重占用。可以全局访问。
- 确保一个类只有一个实例，自行实例化并向系统提供这个实例。

单例需要注意的问题：
- 线程安全问题
- 资源使用问题

#### 1. 饿汉式

```java
public class Singleton{
    private static Singleton instance = new Singleton();
    
    private Singleton(){
        
    }
    
    public static Singleton getInstance(){
        return instance;
    }
}
```
- 优点：未调用getInstance()时，实例已经创建，天生线程安全。
- 缺点：如果一直没有调用getInstance()，但是实例已经存在，资源浪费。

#### 2. 懒汉式

```java
public class Singleton{
    private static Singleton instance;
    
    private Singleton(){}
    
    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return intance;
    }
}
```
- 优点：方法被调用时才创建实例，节省资源。
- 缺点：线程不安全。


<font color='red'>只有单线程才是单例，多线程可能出现多个单例。</font>

#### 3. synchronized加锁同步

```java
public class Singleton(){
    private static Singleton instance;
    
    private Singleton(){}
    
    public synchronized static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```
- 优点：同时满足单线程、多线程。
- 缺点：性能差。

#### 4. 双重校验

```java
public class Singleton(){
    private static Singleton instance;
    
    private Singleton(){}
    
    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

- 优点：同时满足单线程、多线程；性能问题得到优化。
- 缺点：第一次加载慢，由于java内存模型一些原因偶尔失败。

#### 5. volatile关键字


```java
public class Singleton{
    private static volatile instance;
    
    private Singleton(){}
    
    public static Singleton getInstance(){
        if(instance = null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
<font color='red'>volatile关键字可以解决指令重排。</font>如果没有volatile，两个线程AB，都是第一次调用方法，线程A先执行new，该构造方法是非原子性操作，编译后产生多条字节码指令，由于指令重排，可能会先执行赋值操作，即在内存中开辟空间，然后返回内存的引用，之后instance不再为空，但是实际初始化并未完成，此时线程B进入就会看到不为空但是不完整（初始化未完成）的Singleton对象，所以需要加入volatile关键字，禁止指令重排序优化，从而安全的实现单例。

#### 6. 静态内部类

静态内部类由JVM来保证线程安全。

```java
public class Singleton{
    private Singleton(){}
    
    private static class SingletonHolder{
        private static Singleton instance = new Singleton();
    }
    
    public static Singleton getInstance(){
        return SingletonsHolder.instance;
    }
}
```
- 优点：资源利用率高，不执行getInstance()不被实例，可以执行该类其他静态方法。

#### 7. 枚举类实现单例

```
使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。
——Joshua Bloch《effective java》
```
<font color='red'>枚举天生线程安全，且可避免反序列化破坏单例。</font>

more detail：[为什么我强烈建议大家使用枚举来实现单例](https://blog.csdn.net/moakun/article/details/80688851)
```java
public enum Singleton{
    INSTANCE;  
    public void whateverMethod() {  
    }  
}
```

## 2. 结构型

### 2.1. 适配器模式

![Adapter](/image/interview_prep/Adapter.png)

场景：结城明日奈想试试双刀流技能（<font color='red'>一个类的接口</font>）好不好玩，但是亚丝娜这个账号（<font color='red'>客户端所期待的接口</font>）没办法直接用双刀流（<font color='red'>接口不匹配的两个类无法一起工作</font>），只能借助适配器。

#### 1. 类适配器
参考：[Java设计模式之《适配器模式》及应用场景](https://www.cnblogs.com/V1haoge/p/6479118.html)

原理：通过继承来实现适配器功能。

当我们要访问的接口A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，我们又不能改变访问接口A，在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要实现我们访问的接口A，这样我们就能继续访问当前接口A中的方法（虽然它目前不是我们的菜），然后再继承接口B的实现类BB，这样我们可以在适配器P中访问接口B的方法了，这时我们在适配器P中的接口A方法中直接引用BB中的合适方法，这样就完成了一个简单的类适配器。

```java
// 亚丝娜账号
public interface IAsuna{
    void login();
}
// 双刀流
public interface IShuangDaoSkil{
    void releaseSkill();
}
// 双刀流实现类
public class ShuangDaoSkil implements IShuangDaoSkil{
    @Override 
    public void releaseSkill(){
        System.out.println("发动双刀流！");
    }
}
// 适配器
public class Adapter extends ShuangDaoSkil implements IAsuna{
    @Override 
    public void login(){
        releaseSkill();
    }
}

public class client{
    public static void main(String[] args) {
        IAsuna asuna = new Adapter();
        asuna.login();
    }
} 
```
#### 2. 对象适配器模式
原理：通过组合来实现适配器功能。

当我们要访问的接口A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，我们又不能改变访问接口A，在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要实现我们访问的接口A，这样我们就能继续访问当前接口A中的方法（虽然它目前不是我们的菜），然后在适配器P中定义私有变量C（对象）（B接口指向变量名），再定义一个带参数的构造器用来为对象C赋值，再在A接口的方法实现中使用对象C调用其来源于B接口的方法。


```java
// 亚丝娜账号
public interface IAsuna{
    void login();
}
// 双刀流
public interface IShuangDaoSkil{
    void releaseSkill();
}
// 双刀流实现类
public class ShuangDaoSkil implements IShuangDaoSkil{
    @Override 
    public void releaseSkill(){
        System.out.println("发动双刀流！");
    }
}
// 适配器
public class Adapter implements IAsuna {
    private ShuangDaoSkil shuangDaoSkill;
    public Adapter(ShuangDaoSkil shuangDaoSkill){
        this.shuangDaoSkill = shuangDaoSkill;
    }
    @Override
    public void login(){
        shuangDaoSkill.releaseSkill();
    }
}
public class client{
    public static void main(String[] args) {
        IAsuna asuna = new Adapter(new ShuangDaoSkil());
        asuna.login();
    }
} 
```

#### 3. 接口适配器模式

原理：通过抽象类来实现适配，这种适配稍别于上面所述的适配。

当存在这样一个接口，其中定义了N多的方法，而我们现在却只想使用其中的一个到几个方法，如果我们直接实现接口，那么我们要对所有的方法进行实现，哪怕我们仅仅是对不需要的方法进行置空（只写一对大括号，不做具体方法实现）也会导致这个类变得臃肿，调用也不方便，这时我们可以使用一个抽象类作为中间件，即适配器，用这个抽象类实现接口，而在抽象类中所有的方法都进行置空，那么我们在创建抽象类的继承类，而且重写我们需要使用的那几个方法即可。

```java
// 目标接口
public interface ISkill{
    void skill1();
    void skill2();
    void skill3();
    void skill4();
    void skill5();
}
// 适配器
public abstract Adapter implements ISkill{
    public void skill1();
    public void skill2();
    public void skill3();
    public void skill4();
    public void skill5();
}
// 适配器实现类
public class Skill extends Adapter{
    public void skill1();
    public void skill2();
}
public class client{
    public static void main(String[] args) {
        Skill skill = new Skill;
        skill.skill1();
        skill.skill2();
    }
} 
```
#### 4. 使用场景

类适配器与对象适配器的使用场景一致，仅仅是实现手段稍有区别，二者主要用于如下场景：

- 想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。
- 我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。

以上两个场景其实就是从两个角度来描述一类问题，那就是要访问的方法不在合适的接口里，一个从接口出发（被访问），一个从访问出发（主动访问）。

接口适配器使用场景：

想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器。

### 2.2. 装饰器

参考：[JAVA装饰器模式](https://www.cnblogs.com/qiumingcheng/p/5219631.html)、
[Java设计模式之装饰者模式](https://www.cnblogs.com/lzb1096101803/p/4425483.html)

![Decorator](/image/interview_prep/Decorator.png)

Decorator装饰器，顾名思义，就是动态地给一个对象添加一些额外的职责，就好比为房子进行装修一样。因此，装饰器模式具有如下的特征：
- 它必须具有一个装饰的对象。
- 它必须拥有与被装饰对象相同的接口。
- 它可以给被装饰对象添加额外的功能。

用一句话总结就是：<font color='red'>保持接口，增强性能。</font>

实际上是基于对象的适配器模式的一种变种。它与对象的适配器模式的异同点如下:
- 相同点：都拥有一个目标对象。
- 不同点：适配器模式需要实现另外一个接口，而装饰器模式必须实现该对象的接口。

要实现装饰者模式,注意一下几点内容:
1. 装饰者类要实现真实类<font color='red'>同样的接口</font>
2. 装饰者类内有一个<font color='red'>真实对象的引用</font>(可以通过装饰者类的构造器传入)
3. 装饰类对象在主类中接受请求,将<font color='red'>请求发送给真实的对象</font>(相当于已经将引用传递到了装饰类的真实对象)
4. 装饰者可以在传入真实对象后,<font color='red'>增加一些附加功能</font>(因为装饰对象和真实对象都有同样的方法,装饰对象可以添加一定操作在调用真实对象的方法,或者先调用真实对象的方法,再添加自己的方法)
5. 不用继承

来个实例 桐人砍怪：

```java
// 砍怪的接口
public interface IKirito{
    void takeSword();
    void releaseSkill();
    void getAward();
    void operation();
}
// 正常砍怪的实现类
public class Kirito implements IKirito{
    @Override
    public void takeSword(){
        System.out.println("取武器");
    }
    @Override
    public void releaseSkill(){
        System.out.println("放技能");
    }
    @Override
    public void getAward(){
        System.out.println("捡装备");
    }
    @Override
    public void operation() {
        takeSword();
        releaseSkill();
        getAward();
    }
}
// 定义出需要添加附加功能的抽象类
public abstract class AbstractKirito implements IKirito{
    private IKirito kirito;
    public AbstractKirito (IKirito kirito){
        super();
        this.kirito = kirito;
    }

    @Override
    public void takeSword(){
        this.kirito.takeSword();
    }
    @Override
    public void releaseSkill(){
        this.kirito.releaseSkill();
    }
    @Override
    public void getAward(){
        this.kirito.getAward();
    }
    @Override
    public void operation() {
        takeSword();
        releaseSkill();
        getAward();
    }
}
// 继承Abstarct类,所以可以有选择的覆盖正常生产馒头的方法,并添加原有方法原来的信息,同时也可以添加自己的方法    
//装饰者模式中这里最关键, 对应上述的第1个注意点:装饰者类要实现真实类同样的接口

public class WisdomDecorator extends AbstractKirito{
    public WisdomDecorator(IKirito kirito){
        super(kirito);
    }

    public void addWisdomBuff(){
        System.out.println("加智力buff");
    }

    @Override
    public void releaseSkill() {
        this.addWisdomBuff();
        super.releaseSkill();
    }
}

public class StrengthDecorator extends AbstractKirito{
    public StrengthDecorator(IKirito kirito){
        super(kirito);
    }

    public void addStrenthBuff(){
        System.out.println("加力量buff");
    }

    @Override
    public void releaseSkill() {
        this.addStrenthBuff();
        super.releaseSkill();
    }
}
public class AgilityDecorator extends AbstractKirito{
    public AgilityDecorator(IKirito kirito){
        super(kirito);
    }

    public void addAgilityBuff(){
        System.out.println("加敏捷buff");
    }

    @Override
    public void releaseSkill() {
        this.addAgilityBuff();
        super.releaseSkill();
    }
}

public class client{
    public static void main(String[] args) {
        IKirito kirito = new Kirito();
        kirito = new WisdomDecorator(kirito);
        kirito = new StrengthDecorator(kirito);
        kirito = new AgilityDecorator(kirito);
        kirito.operation();
    }
}
```
输出：
```
取武器
加敏捷buff
加力量buff
加智力buff
放技能
捡装备
```

装饰者模式中的4个角色
- 被装饰者抽象Component:是一个接口或者抽象类,定义最核心的对象,这个类是装饰者的基类,例如IKirito接口
- 被装饰者具体实现ConcreteComponent:这是Component接口或抽象类的实现,例如本例中的Kirito
- 装饰者Decorator:一般是抽象类,实现Component,它里面必然有一个指向Component的引用,例如本例中AbstractKirito
- 装饰者实现ConcreteDecorator1和ConcreteDecorator2:用来装饰最基本的类,如本例中的AgilityDecorator


### 2.3 代理模式
参考：[理解java的三种代理模式](https://www.cnblogs.com/boboxing/p/8126046.html)

![Proxy](/image/interview_prep/Proxy.png)

代理模式是一种设计模式，简单说即是在不改变源码的情况下，实现对目标对象的功能扩展。

#### 1. 静态代理


```java
public interface IPlayer{
    void play();
}

public class Player implements IPlayer{
    @Override
    public void play(){
        System.out.println("进行游戏");
    }
}

public class PlayerProxy implements IPlayer{
    private IPlayer player;
    
    public PlayerProxy(IPlayer player){
        this.player = player;
    }
    @Override
    public void play(){
        System.out.println("寻找伙伴");
        player.play();
    }
}

public class Test{
    public static void main(String[] args) {
        IPlayer player = new Player();
        PlayerProxy proxy = new PlayerProxy(player);
        proxy.play();
    }
}
```

**总结**：其实这里做的事情无非就是，创建一个代理类SingerProxy，继承了ISinger接口并实现了其中的方法。只不过这种实现特意包含了目标对象的方法，正是这种特征使得看起来像是“扩展”了目标对象的方法。假使代理对象中只是简单地对sing方法做了另一种实现而没有包含目标对象的方法，也就不能算作代理模式了。所以这里的包含是关键。

**缺点**：这种实现方式很直观也很简单，但其缺点是代理对象必须提前写出，如果接口层发生了变化，代理对象的代码也要进行维护。如果能在运行时动态地写出代理对象，不但减少了一大批代理类的代码，也少了不断维护的烦恼，不过运行时的效率必定受到影响。这种方式就是接下来的动态代理。

#### 2. 动态代理（JDK代理）
跟静态代理的前提一样，依然是对Singer对象进行扩展

```java
public interface IPlayer{
    void play();
}

public class Player implements IPlayer{
    @Override
    public void play(){
        System.out.println("进行游戏");
    }
}
```

调用Proxy类的静态方法newProxyInstance即可，该方法会返回代理类对象

```java
public class Test{
    public static void main(String[] args) {
        // 1. 创建实例
        Player target = new Player();
        IPlayer proxy  = (IPlayer) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        // 2. 扩展1
                        System.out.println("寻找伙伴");
                        //执行目标对象方法
                        Object returnValue = method.invoke(target, args);
                        // 3. 扩展2
                        System.out.println("很开心");
                        return returnValue;
                    }
                });
        // 4. 目标对象的方法
        proxy.play();
    }
}
```
**总结**：以上代码只有1234部分是需要自己写出，其余部分全都是固定代码。由于java封装了newProxyInstance这个方法的实现细节，所以使用起来才能这么方便。
**缺点**：可以看出静态代理和JDK代理有一个共同的缺点，就是目标对象必须实现一个或多个接口，假如没有，则可以使用Cglib代理。

#### 3. Cglib代理
前提条件：

- 需要引入cglib的jar文件，由于Spring的核心包中已经包括了Cglib功能，所以也可以直接引入spring-core-3.2.5.jar
- 目标类不能为final
- 目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法

```java
public class Player {
    public void play(){
        System.out.println("进行游戏");
    }
}
```


```java
/**
 * Cglib子类代理工厂
 */
public class ProxyFactory implements MethodInterceptor{
    // 维护目标对象
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    // 给目标对象创建一个代理对象
    public Object getProxyInstance(){
        //1.工具类
        Enhancer en = new Enhancer();
        //2.设置父类
        en.setSuperclass(target.getClass());
        //3.设置回调函数
        en.setCallback(this);
        //4.创建子类(代理对象)
        return en.create();
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // 步骤1
        System.out.println("寻找伙伴");
        //执行目标对象的方法
        Object returnValue = method.invoke(target, args);
        // 步骤2
        System.out.println("很开心");
        return returnValue;
    }
}


/**
 * 测试类
 */
public class Test{
    public static void main(String[] args){
        //目标对象
        Player target = new Player();
        //代理对象
        Player proxy = (Player)new ProxyFactory(target).getProxyInstance();
        //执行代理对象的方法
        proxy.play();
    }
}
```

这里的代码也非常固定，只有步骤1、2是需要自己写出.

**总结**：三种代理模式各有优缺点和相应的适用范围，主要看目标对象是否实现了接口。

以Spring框架所选择的代理模式举例：在Spring的AOP编程中：
- 如果加入容器的目标对象有实现接口，用JDK代理
- 如果目标对象没有实现接口，用Cglib代理

## 3. 行为型

### 3.1 模板方法模式
参考：[java设计模式之模板方法模式](https://www.cnblogs.com/liaoweipeng/p/5790395.html)

![TemplateMethod](/image/interview_prep/TemplateMethod.png)

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<font color = 'red'>通俗的说的就是有很多相同的步骤的，在某一些地方可能有一些差别适合于这种模式，如大话设计模式中说到的考试场景中，每个人的试卷都是一样的，只有答案不一样。这种场景就适合于模板方法模式。</font>


```java
// 用抽象基类定义算法框架
public abstract class PlayGame{
    /*
     * 模板方法 封装了所有子类所遵循的算法框架
     */
    public final void play(){
        login();
        if(isPlyerWantsBuff()){
            addBuff();
        }
        releaseSkill();
        getAward();
    }
    // 因为login和getAward对所有子类是共同的行为，所以没必要向子类过多开放，所以方法定义为private，这样我们在进行子类编码时可以减少复杂度。
    // 这样不需要关注细枝末节，我们只需要关注我们特定业务的实现，这就是模板方法模式的好处。可以封装变与不变，将不变的固化在高层，隐藏其细节。
    private void login(){
        System.out.println("登陆游戏");
    }
    private void getAward(){
        System.out.println("捡装备");
    }
    /*
     * Hook 钩子函数,提供一个空的或者默认的实现 子类重写该方法，可以自行决定是否挂钩以及如何挂钩
     */
    protected boolean isPlyerWantsBuff(){
        return true;
    }
    /*
     * addBuff()和releaseSkill()这两个方法我们不知道它们在算法框架中的具体实现，因此定义为抽象方法，
     * 我们用protected进行修饰， 在子类中可见便于进行重写。
     */
    protected abstract void addBuff();
    protected abstract void releaseSkill();

}
// 具体子类延迟实现步骤
/**
 * 提供制备咖啡的具体实现子类。 具体子类实现延迟步骤，满足特定的业务需求。
 *
 *
 */
public class AsunaPlayGame extends PlayGame{
    @Override
    protected void addBuff(){
        System.out.println("加敏捷Buff");
    }
    @Override
    protected void releaseSkill(){
        System.out.println("释放圣母圣咏");
    }
}
public class KiritoPlayGame extends PlayGame{
    @Override
    protected boolean isPlyerWantsBuff(){
        return false;
    }
    @Override
    protected void addBuff(){
        System.out.println("加敏捷Buff");
    }
    @Override
    protected void releaseSkill(){
        System.out.println("释放星爆弃疗斩");
    }
}
// 测试类
public class client{
    public static void main(String[] args) {
        System.out.println("Kirito 开始游戏");
        PlayGame kirito = new KiritoPlayGame();
        kirito.play();

        System.out.println("\n*********************************");
        System.out.println("Asuna 开始游戏");
        PlayGame asuna = new AsunaPlayGame();
        asuna.play();
    }
}

```

控制台输出：
```
Kirito 开始游戏
登陆游戏
释放星爆弃疗斩
捡装备

*********************************
Asuna 开始游戏
登陆游戏
加敏捷Buff
释放圣母圣咏
捡装备
```

模板方法模式适用场景：
- 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的- 操作的模板方法来替换这些不同的代码。
- 控制子类扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展。

### 3.2 观察者模式
参考：[JAVA设计模式之观察者模式](https://www.cnblogs.com/luohanguo/p/7825656.html)

![Observer](/image/interview_prep/Observer.png)

定义：在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。
解释：其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。

- **抽象被观察者角色**：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。
- **抽象观察者角色**：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。
- **具体被观察者角色**：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。
- **具体观察者角色**：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。

#### 场景
有一个NPC务，不定时发布一些任务，在线玩家就可以收到推送消息，不在线就收不到推送消息。

```java
/***
 * 抽象被观察者接口
 * 声明了添加、删除、通知观察者方法
 *
 */
public interface Observerable{
    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObserver();
}
/***
 * 抽象观察者
 * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。
 *
 */
public interface Observer {
    public void update(String message);
}

/**
 * 被观察者，也就是微信公众号服务
 * 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现
 */
public class NPC implements Observerable{
    private List<Observer> list;
    private String message;

    public NPC(){
        list = new ArrayList<>();
    }
    @Override
    public void registerObserver(Observer o){
        list.add(o);
    }
    @Override
    public void removeObserver(Observer o){
        if(!list.isEmpty()){
            list.remove(o);
        }
    }
    @Override
    public void notifyObserver(){
        for(Observer o : list){
            o.update(message);
        }
    }
    public void setMessage(String message){
        this.message = message;
        System.out.println("NPC发布新任务： " + message);
        notifyObserver();
    }
}
/**
 * 观察者
 * 实现了update方法
 */
public class Player implements Observer{
    private String name;
    private String message;
    public Player(String name){
        this.name = name;
    }
    @Override
    public void update(String message){
        this.message = message;
        receive(message);
    }
    public void receive(String message){
        System.out.println(this.name + " 收到任务 " + message);
    }
}
// 测试类
public class client{
    public static void main(String[] args) {
        NPC npc = new NPC();
        Player kirito = new Player("Kirito");
        Player asuna = new Player("Asuna");
        Player shino = new Player("Shino");
        npc.registerObserver(kirito);
        npc.registerObserver(asuna);
        npc.registerObserver(shino);
        npc.setMessage("第19层boss");
        System.out.println("----------------------------------------------");
        System.out.println("Shino掉线");
        npc.removeObserver(shino);
        npc.setMessage("第23层boss");
    }
}
```
控制台输出：
```
NPC发布新任务： 第19层boss
Kirito 收到任务 第19层boss
Asuna 收到任务 第19层boss
Shino 收到任务 第19层boss
----------------------------------------------
Shino掉线
NPC发布新任务： 第23层boss
Kirito 收到任务 第23层boss
Asuna 收到任务 第23层boss
```

#### 总结
- 这个模式是松偶合的。改变主题或观察者中的一方，另一方不会受到影像。
- JDK中也有自带的观察者模式。但是被观察者是一个类而不是接口，限制了它的复用能力。
- 在JavaBean和Swing中也可以看到观察者模式的影子。